{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "eltazr3-adf"
		},
		"ls_storage_curated_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ls_storage_curated'"
		},
		"ls_syn_sql_password": {
			"type": "secureString",
			"metadata": "Secure string for 'password' of 'ls_syn_sql'"
		},
		"AzureSynapseArtifacts1_properties_typeProperties_endpoint": {
			"type": "string",
			"defaultValue": "https://eltazr3-syn.dev.azuresynapse.net"
		},
		"AzureSynapseArtifacts2_properties_typeProperties_endpoint": {
			"type": "string",
			"defaultValue": "https://eltazr3-syn.dev.azuresynapse.net"
		},
		"ls_adls_raw_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://eltazr3adls.dfs.core.windows.net/"
		},
		"ls_adls_raw_adf_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://eltazr3adls.dfs.core.windows.net/"
		},
		"ls_syn_sql_properties_typeProperties_server": {
			"type": "string",
			"defaultValue": "eltazr3-syn.sql.azuresynapse.net"
		},
		"ls_syn_sql_properties_typeProperties_database": {
			"type": "string",
			"defaultValue": "eltazr3_sqlpool"
		},
		"ls_syn_sql_properties_typeProperties_userName": {
			"type": "string",
			"defaultValue": "synadmin"
		},
		"t_daily_nyctaxi_properties_pipeline_parameters_dataset": {
			"type": "string",
			"defaultValue": "nyctaxi_yellow"
		},
		"t_daily_nyctaxi_properties_pipeline_parameters_run_date": {
			"type": "string",
			"defaultValue": "2025-07-31"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/AzureSynapseArtifacts1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureSynapseArtifacts",
				"typeProperties": {
					"endpoint": "[parameters('AzureSynapseArtifacts1_properties_typeProperties_endpoint')]",
					"authentication": "MSI",
					"workspaceResourceId": "/subscriptions/6c6119b6-a5fd-406b-aa20-45a34495a8d7/resourceGroups/eltazr3-rg/providers/Microsoft.Synapse/workspaces/eltazr3-syn"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureSynapseArtifacts2')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureSynapseArtifacts",
				"typeProperties": {
					"endpoint": "[parameters('AzureSynapseArtifacts2_properties_typeProperties_endpoint')]",
					"authentication": "MSI",
					"workspaceResourceId": "/subscriptions/6c6119b6-a5fd-406b-aa20-45a34495a8d7/resourceGroups/eltazr3-rg/providers/Microsoft.Synapse/workspaces/eltazr3-syn"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_adls_raw')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('ls_adls_raw_properties_typeProperties_url')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_adls_raw_adf')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('ls_adls_raw_adf_properties_typeProperties_url')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_storage_curated')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"connectionString": "[parameters('ls_storage_curated_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_syn_sql')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureSqlDW",
				"typeProperties": {
					"server": "[parameters('ls_syn_sql_properties_typeProperties_server')]",
					"database": "[parameters('ls_syn_sql_properties_typeProperties_database')]",
					"encrypt": "mandatory",
					"trustServerCertificate": false,
					"authenticationType": "SQL",
					"userName": "[parameters('ls_syn_sql_properties_typeProperties_userName')]",
					"password": {
						"type": "SecureString",
						"value": "[parameters('ls_syn_sql_password')]"
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_core_to_mdl_nyctaxi')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "LogStart",
						"type": "Script",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @run_id NVARCHAR(64)='@{pipeline().RunId}';\nDECLARE @stage  NVARCHAR(32)='core_to_mdl';\nDECLARE @ds     NVARCHAR(128)='@{pipeline().parameters.dataset}';\nDECLARE @d      DATE='@{pipeline().parameters.run_date}';\n\nINSERT INTO ops.run_log (run_id, stage, dataset, ingest_date, status, started_at_utc)\nSELECT @run_id, @stage, @ds, @d, 'STARTED', SYSUTCDATETIME();\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "DimVendor_Upsert",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "LogStart",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @d DATE = '@{pipeline().parameters.run_date}';\n\n;WITH src AS (\n  SELECT DISTINCT UPPER(LTRIM(RTRIM(vendor_code))) AS vendor_code_nk\n  FROM core.trip_clean\n  WHERE ingest_date = @d\n    AND vendor_code IS NOT NULL AND LTRIM(RTRIM(vendor_code)) <> ''\n)\nINSERT INTO mdl.dim_vendor (vendor_code_nk, active_flag, valid_from_utc)\nSELECT s.vendor_code_nk, 1, SYSUTCDATETIME()\nFROM src s\nLEFT JOIN mdl.dim_vendor t\n  ON t.vendor_code_nk = s.vendor_code_nk\nWHERE t.vendor_code_nk IS NULL;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "DimPayment_Upsert",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "DimVendor_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @d DATE = '@{pipeline().parameters.run_date}';\n\n;WITH src AS (\n  SELECT DISTINCT UPPER(LTRIM(RTRIM(payment_type))) AS payment_type_nk\n  FROM core.trip_clean\n  WHERE ingest_date = @d\n    AND payment_type IS NOT NULL AND LTRIM(RTRIM(payment_type)) <> ''\n)\nINSERT INTO mdl.dim_payment_type (payment_type_nk)\nSELECT s.payment_type_nk\nFROM src s\nLEFT JOIN mdl.dim_payment_type t\n  ON t.payment_type_nk = s.payment_type_nk\nWHERE t.payment_type_nk IS NULL;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "DimRate_Upsert",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "DimPayment_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @d DATE = '@{pipeline().parameters.run_date}';\n\n;WITH src AS (\n  SELECT DISTINCT CAST(RatecodeID AS VARCHAR(16)) AS rate_code_nk\n  FROM stg.trip\n  WHERE ingest_date = @d\n    AND RatecodeID IS NOT NULL\n)\nINSERT INTO mdl.dim_rate_code (rate_code_nk)\nSELECT s.rate_code_nk\nFROM src s\nLEFT JOIN mdl.dim_rate_code t\n  ON t.rate_code_nk = s.rate_code_nk\nWHERE t.rate_code_nk IS NULL;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "DimFlag_Upsert",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "DimRate_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @d DATE = '@{pipeline().parameters.run_date}';\n\n;WITH src AS (\n  SELECT DISTINCT UPPER(LTRIM(RTRIM(store_and_fwd_flag))) AS flag_nk\n  FROM stg.trip\n  WHERE ingest_date = @d\n    AND store_and_fwd_flag IS NOT NULL\n    AND LTRIM(RTRIM(store_and_fwd_flag)) <> ''\n)\nINSERT INTO mdl.dim_flag (flag_nk, meaning)\nSELECT s.flag_nk, NULL\nFROM src s\nLEFT JOIN mdl.dim_flag t\n  ON t.flag_nk = s.flag_nk\nWHERE t.flag_nk IS NULL;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "DimLocation_Upsert",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "DimFlag_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @d DATE = '@{pipeline().parameters.run_date}';\n\n;WITH src AS (\n  SELECT DISTINCT CAST(PULocationID AS SMALLINT) AS location_id_nk\n  FROM stg.trip\n  WHERE ingest_date = @d AND PULocationID IS NOT NULL\n  UNION\n  SELECT DISTINCT CAST(DOLocationID AS SMALLINT) AS location_id_nk\n  FROM stg.trip\n  WHERE ingest_date = @d AND DOLocationID IS NOT NULL\n)\nINSERT INTO mdl.dim_location (location_id_nk)\nSELECT s.location_id_nk\nFROM src s\nLEFT JOIN mdl.dim_location t\n  ON t.location_id_nk = s.location_id_nk\nWHERE t.location_id_nk IS NULL;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "FactTrip_Load",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "DimVendor_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "DimPayment_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "DimRate_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "DimFlag_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "DimLocation_Upsert",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @d DATE = '@{pipeline().parameters.run_date}';\n\n-- 1) Idempotent delete\nDELETE FROM mdl.fact_trip WHERE ingest_date = @d;\n\n-- 2) Prepare the staging and core slices + correlation\nWITH c AS (\n  SELECT\n    vendor_code,\n    pickup_ts_utc,\n    dropoff_ts_utc,\n    trip_distance_km,\n    fare_amount,\n    payment_type,\n    ingest_date,\n    source_file_name,\n    loaded_at\n  FROM core.trip_clean\n  WHERE ingest_date = @d\n),\ns AS (\n  SELECT\n    -- Recompute comparable types from stg\n    UPPER(LTRIM(RTRIM(CONVERT(VARCHAR(32), VendorID))))                 AS vendor_code_nk,\n    TRY_CONVERT(DATETIME2, tpep_pickup_datetime)                         AS pickup_ts_utc,\n    TRY_CONVERT(DATETIME2, tpep_dropoff_datetime)                        AS dropoff_ts_utc,\n    ROUND(TRY_CAST(trip_distance AS FLOAT) * 1.609344, 3)                AS trip_distance_km_stg,\n    TRY_CAST(fare_amount AS DECIMAL(9,2))                                AS fare_amount_clean,\n    CAST(RatecodeID AS VARCHAR(16))                                      AS rate_code_nk,\n    UPPER(LTRIM(RTRIM(store_and_fwd_flag)))                              AS flag_nk,\n    CAST(PULocationID AS SMALLINT)                                       AS pu_location_nk,\n    CAST(DOLocationID AS SMALLINT)                                       AS do_location_nk,\n    TRY_CAST(tip_amount AS DECIMAL(10,2))                                AS tip_amount,\n    TRY_CAST(tolls_amount AS DECIMAL(10,2))                              AS tolls_amount,\n    TRY_CAST(total_amount AS DECIMAL(10,2))                              AS total_amount,\n    ingest_date,\n    source_file_name,\n    loaded_at\n  FROM stg.trip\n  WHERE ingest_date = @d\n),\nj AS (\n  -- Correlate 1 core row to its best stg row using lineage + cleaned keys\n  SELECT\n    c.*,\n    s.rate_code_nk, s.flag_nk, s.pu_location_nk, s.do_location_nk,\n    s.tip_amount, s.tolls_amount, s.total_amount,\n    ROW_NUMBER() OVER (\n      PARTITION BY\n        c.vendor_code, c.pickup_ts_utc, c.dropoff_ts_utc,\n        c.fare_amount, c.trip_distance_km\n      ORDER BY s.loaded_at DESC, s.source_file_name DESC\n    ) AS rn\n  FROM c\n  LEFT JOIN s\n    ON c.ingest_date = s.ingest_date\n   AND c.source_file_name = s.source_file_name\n   AND c.pickup_ts_utc   = s.pickup_ts_utc\n   AND c.dropoff_ts_utc  = s.dropoff_ts_utc\n   AND c.fare_amount     = s.fare_amount_clean\n   AND c.trip_distance_km = s.trip_distance_km_stg\n   AND UPPER(LTRIM(RTRIM(c.vendor_code))) = s.vendor_code_nk\n),\npicked AS (\n  SELECT *\n  FROM j\n  WHERE rn = 1\n),\nkeyed AS (\n  -- Map NKs to SKs and compute date/time keys\n  SELECT\n    -- Deterministic trip_id (SHA-256 hex) built from the same dedupe columns used in core\n    CONVERT(CHAR(64),\n      HASHBYTES('SHA2_256', CONCAT(\n        COALESCE(UPPER(LTRIM(RTRIM(vendor_code))),'') , '|',\n        CONVERT(VARCHAR(23), pickup_ts_utc, 126)      , '|',\n        CONVERT(VARCHAR(23), dropoff_ts_utc, 126)     , '|',\n        CONVERT(VARCHAR(50), CAST(fare_amount AS DECIMAL(18,2))) , '|',\n        CONVERT(VARCHAR(50), CAST(trip_distance_km AS DECIMAL(18,3))) , '|',\n        COALESCE(UPPER(LTRIM(RTRIM(payment_type))),'')\n      ))\n    , 2) AS trip_id,\n\n    (YEAR(pickup_ts_utc)*10000 + MONTH(pickup_ts_utc)*100 + DAY(pickup_ts_utc)) AS pickup_date_key,\n    (DATEPART(HOUR, pickup_ts_utc) * 3600 +\n     DATEPART(MINUTE, pickup_ts_utc) * 60 +\n     DATEPART(SECOND, pickup_ts_utc)) AS pickup_time_key,\n\n    -- Lookups (COALESCE to -1 unknown if not found)\n    COALESCE(v.vendor_key, -1)         AS vendor_key,\n    COALESCE(p.payment_type_key, -1)   AS payment_type_key,\n    COALESCE(r.rate_code_key, -1)      AS rate_code_key,\n    COALESCE(f.flag_key, -1)           AS flag_key,\n    COALESCE(pu.location_key, -1)      AS pu_location_key,\n    COALESCE(do_.location_key, -1)     AS do_location_key,\n\n    trip_distance_km,\n    fare_amount,\n    tip_amount,\n    tolls_amount,\n    total_amount,\n    ingest_date,\n    source_file_name,\n    loaded_at\n  FROM picked x\n  LEFT JOIN mdl.dim_vendor        v  ON v.vendor_code_nk   = UPPER(LTRIM(RTRIM(x.vendor_code)))\n  LEFT JOIN mdl.dim_payment_type  p  ON p.payment_type_nk  = UPPER(LTRIM(RTRIM(x.payment_type)))\n  LEFT JOIN mdl.dim_rate_code     r  ON r.rate_code_nk     = x.rate_code_nk\n  LEFT JOIN mdl.dim_flag          f  ON f.flag_nk          = x.flag_nk\n  LEFT JOIN mdl.dim_location      pu ON pu.location_id_nk  = x.pu_location_nk\n  LEFT JOIN mdl.dim_location      do_ ON do_.location_id_nk = x.do_location_nk\n)\nINSERT INTO mdl.fact_trip\n(\n  trip_id,\n  pickup_date_key, pickup_time_key,\n  pu_location_key, do_location_key,\n  vendor_key, payment_type_key, rate_code_key, flag_key,\n  trip_distance_km, fare_amount, tip_amount, tolls_amount, total_amount,\n  ingest_date, source_file_name, loaded_at\n)\nSELECT\n  trip_id,\n  pickup_date_key, pickup_time_key,\n  pu_location_key, do_location_key,\n  vendor_key, payment_type_key, rate_code_key, flag_key,\n  trip_distance_km, fare_amount, tip_amount, tolls_amount, total_amount,\n  ingest_date, source_file_name, loaded_at\nFROM keyed;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "ModelDQ_Gate",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "PostLoad_Stats",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @d DATE = '@{pipeline().parameters.run_date}';\n\n-- 1) Idempotent delete\nDELETE FROM mdl.fact_trip WHERE ingest_date = @d;\n\n-- 2) Prepare slices\nWITH c AS (\n  SELECT\n    -- A unique, deterministic id for each core row in this slice\n    ROW_NUMBER() OVER (\n      ORDER BY\n        source_file_name, loaded_at,\n        vendor_code, pickup_ts_utc, dropoff_ts_utc,\n        fare_amount, trip_distance_km, payment_type\n    ) AS core_row_id,\n    vendor_code,\n    pickup_ts_utc,\n    dropoff_ts_utc,\n    trip_distance_km,\n    fare_amount,\n    payment_type,\n    ingest_date,\n    source_file_name,\n    loaded_at\n  FROM core.trip_clean\n  WHERE ingest_date = @d\n),\ns AS (\n  SELECT\n    UPPER(LTRIM(RTRIM(CONVERT(VARCHAR(32), VendorID))))        AS vendor_code_nk,\n    TRY_CONVERT(DATETIME2, tpep_pickup_datetime)                AS pickup_ts_utc,\n    TRY_CONVERT(DATETIME2, tpep_dropoff_datetime)               AS dropoff_ts_utc,\n    ROUND(TRY_CAST(trip_distance AS FLOAT) * 1.609344, 3)       AS trip_distance_km_stg,\n    TRY_CAST(fare_amount AS DECIMAL(9,2))                       AS fare_amount_clean,\n    CAST(RatecodeID AS VARCHAR(16))                             AS rate_code_nk,\n    UPPER(LTRIM(RTRIM(store_and_fwd_flag)))                     AS flag_nk,\n    CAST(PULocationID AS SMALLINT)                              AS pu_location_nk,\n    CAST(DOLocationID AS SMALLINT)                              AS do_location_nk,\n    TRY_CAST(tip_amount AS DECIMAL(10,2))                       AS tip_amount,\n    TRY_CAST(tolls_amount AS DECIMAL(10,2))                     AS tolls_amount,\n    TRY_CAST(total_amount AS DECIMAL(10,2))                     AS total_amount,\n    ingest_date,\n    source_file_name,\n    loaded_at\n  FROM stg.trip\n  WHERE ingest_date = @d\n),\nj AS (\n  -- LEFT JOIN so every core row survives even if no stg row matches\n  SELECT\n    c.*,\n    s.rate_code_nk, s.flag_nk, s.pu_location_nk, s.do_location_nk,\n    s.tip_amount, s.tolls_amount, s.total_amount,\n    ROW_NUMBER() OVER (\n      PARTITION BY c.core_row_id\n      ORDER BY s.loaded_at DESC, s.source_file_name DESC\n    ) AS rn\n  FROM c\n  LEFT JOIN s\n    ON c.ingest_date      = s.ingest_date\n   AND c.source_file_name = s.source_file_name\n   AND c.pickup_ts_utc    = s.pickup_ts_utc\n   AND c.dropoff_ts_utc   = s.dropoff_ts_utc\n),\npicked AS (\n  SELECT * FROM j WHERE rn = 1\n),\nkeyed AS (\n  SELECT\n    CONVERT(CHAR(64),\n      HASHBYTES('SHA2_256', CONCAT(\n        COALESCE(UPPER(LTRIM(RTRIM(vendor_code))),'') , '|',\n        CONVERT(VARCHAR(23), pickup_ts_utc, 126)      , '|',\n        CONVERT(VARCHAR(23), dropoff_ts_utc, 126)     , '|',\n        CONVERT(VARCHAR(50), CAST(fare_amount AS DECIMAL(18,2))) , '|',\n        CONVERT(VARCHAR(50), CAST(trip_distance_km AS DECIMAL(18,3))) , '|',\n        COALESCE(UPPER(LTRIM(RTRIM(payment_type))),'')\n      ))\n    , 2) AS trip_id,\n\n    (YEAR(pickup_ts_utc)*10000 + MONTH(pickup_ts_utc)*100 + DAY(pickup_ts_utc)) AS pickup_date_key,\n    (DATEPART(HOUR, pickup_ts_utc) * 3600 +\n     DATEPART(MINUTE, pickup_ts_utc) * 60 +\n     DATEPART(SECOND, pickup_ts_utc)) AS pickup_time_key,\n\n    COALESCE(v.vendor_key, -1)       AS vendor_key,\n    COALESCE(p.payment_type_key, -1) AS payment_type_key,\n    COALESCE(r.rate_code_key, -1)    AS rate_code_key,\n    COALESCE(f.flag_key, -1)         AS flag_key,\n    COALESCE(pu.location_key, -1)    AS pu_location_key,\n    COALESCE(do_.location_key, -1)   AS do_location_key,\n\n    trip_distance_km,\n    fare_amount,\n    tip_amount,\n    tolls_amount,\n    total_amount,\n    ingest_date,\n    source_file_name,\n    loaded_at\n  FROM picked x\n  LEFT JOIN mdl.dim_vendor        v  ON v.vendor_code_nk   = UPPER(LTRIM(RTRIM(x.vendor_code)))\n  LEFT JOIN mdl.dim_payment_type  p  ON p.payment_type_nk  = UPPER(LTRIM(RTRIM(x.payment_type)))\n  LEFT JOIN mdl.dim_rate_code     r  ON r.rate_code_nk     = x.rate_code_nk\n  LEFT JOIN mdl.dim_flag          f  ON f.flag_nk          = x.flag_nk\n  LEFT JOIN mdl.dim_location      pu ON pu.location_id_nk  = x.pu_location_nk\n  LEFT JOIN mdl.dim_location      do_ ON do_.location_id_nk = x.do_location_nk\n)\nINSERT INTO mdl.fact_trip\n(\n  trip_id,\n  pickup_date_key, pickup_time_key,\n  pu_location_key, do_location_key,\n  vendor_key, payment_type_key, rate_code_key, flag_key,\n  trip_distance_km, fare_amount, tip_amount, tolls_amount, total_amount,\n  ingest_date, source_file_name, loaded_at\n)\nSELECT\n  trip_id,\n  pickup_date_key, pickup_time_key,\n  pu_location_key, do_location_key,\n  vendor_key, payment_type_key, rate_code_key, flag_key,\n  trip_distance_km, fare_amount, tip_amount, tolls_amount, total_amount,\n  ingest_date, source_file_name, loaded_at\nFROM keyed;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "LogSuccess",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "ModelDQ_Gate",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @run_id NVARCHAR(64)='@{pipeline().RunId}';\nDECLARE @stage  NVARCHAR(32)='core_to_mdl';\nDECLARE @d      DATE='@{pipeline().parameters.run_date}';\nDECLARE @rows   BIGINT=(SELECT COUNT(*) FROM mdl.fact_trip WHERE ingest_date=@d);\n\nUPDATE ops.run_log\n   SET status='SUCCEEDED', rows_copied=@rows, finished_at_utc=SYSUTCDATETIME()\n WHERE run_id=@run_id AND stage=@stage;\n\nIF NOT EXISTS (SELECT 1 FROM ops.run_log WHERE run_id=@run_id AND stage=@stage)\nINSERT INTO ops.run_log (run_id, stage, dataset, ingest_date, status, started_at_utc, finished_at_utc, rows_copied)\nSELECT @run_id, @stage, '@{pipeline().parameters.dataset}', @d, 'SUCCEEDED', SYSUTCDATETIME(), SYSUTCDATETIME(), @rows;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "LogFailure",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "ModelDQ_Gate",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @run_id NVARCHAR(64)='@{pipeline().RunId}';\nDECLARE @stage  NVARCHAR(32)='core_to_mdl';\nDECLARE @d      DATE='@{pipeline().parameters.run_date}';\nDECLARE @rows   BIGINT=(SELECT COUNT(*) FROM mdl.fact_trip WHERE ingest_date=@d);\n\nUPDATE ops.run_log\n   SET status='FAILED', rows_copied=@rows, finished_at_utc=SYSUTCDATETIME()\n WHERE run_id=@run_id AND stage=@stage;\n\nIF NOT EXISTS (SELECT 1 FROM ops.run_log WHERE run_id=@run_id AND stage=@stage)\nINSERT INTO ops.run_log (run_id, stage, dataset, ingest_date, status, started_at_utc, finished_at_utc, rows_copied)\nSELECT @run_id, @stage, '@{pipeline().parameters.dataset}', @d, 'FAILED', SYSUTCDATETIME(), SYSUTCDATETIME(), @rows;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "PostLoad_Stats",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "FactTrip_Load",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "-- Post-load statistics refresh for Modeling layer\n-- Safe to run every slice; idempotent\n\nDECLARE @d DATE = '@{pipeline().parameters.run_date}';\n\n-- One-time stats (created if missing) on common filter/join columns\nIF NOT EXISTS (SELECT 1 FROM sys.stats WHERE object_id = OBJECT_ID('mdl.fact_trip') AND name = 'st_fact_trip_pickup_date_key')\n  CREATE STATISTICS st_fact_trip_pickup_date_key ON mdl.fact_trip(pickup_date_key);\n\nIF NOT EXISTS (SELECT 1 FROM sys.stats WHERE object_id = OBJECT_ID('mdl.fact_trip') AND name = 'st_fact_trip_vendor_key')\n  CREATE STATISTICS st_fact_trip_vendor_key ON mdl.fact_trip(vendor_key);\n\nIF NOT EXISTS (SELECT 1 FROM sys.stats WHERE object_id = OBJECT_ID('mdl.fact_trip') AND name = 'st_fact_trip_payment_type_key')\n  CREATE STATISTICS st_fact_trip_payment_type_key ON mdl.fact_trip(payment_type_key);\n\nIF NOT EXISTS (SELECT 1 FROM sys.stats WHERE object_id = OBJECT_ID('mdl.fact_trip') AND name = 'st_fact_trip_pu_key')\n  CREATE STATISTICS st_fact_trip_pu_key ON mdl.fact_trip(pu_location_key);\n\nIF NOT EXISTS (SELECT 1 FROM sys.stats WHERE object_id = OBJECT_ID('mdl.fact_trip') AND name = 'st_fact_trip_do_key')\n  CREATE STATISTICS st_fact_trip_do_key ON mdl.fact_trip(do_location_key);\n\nIF NOT EXISTS (SELECT 1 FROM sys.stats WHERE object_id = OBJECT_ID('mdl.fact_trip') AND name = 'st_fact_trip_ingest_date')\n  CREATE STATISTICS st_fact_trip_ingest_date ON mdl.fact_trip(ingest_date);\n\n-- Refresh stats after slice insert (keeps plans healthy)\nUPDATE STATISTICS mdl.fact_trip;\n-- Location is the only dim that can grow meaningfully day to day\nUPDATE STATISTICS mdl.dim_location;\n\n-- (Optional) if you expect frequent changes to other dims, uncomment:\n-- UPDATE STATISTICS mdl.dim_vendor;\n-- UPDATE STATISTICS mdl.dim_payment_type;\n-- UPDATE STATISTICS mdl.dim_rate_code;\n-- UPDATE STATISTICS mdl.dim_flag;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"dataset": {
						"type": "string",
						"defaultValue": "nyctaxi_yellow"
					},
					"run_date": {
						"type": "string"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_syn_sql')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stg_to_core_nyctaxi')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "LogStart",
						"type": "Script",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @run_id   NVARCHAR(64)  = '@{pipeline().RunId}';\nDECLARE @stage    NVARCHAR(32)  = 'stg_to_core';\nDECLARE @dataset  NVARCHAR(128) = '@{pipeline().parameters.dataset}';\nDECLARE @ingest   DATE          = '@{pipeline().parameters.run_date}';\n\nINSERT INTO ops.run_log (run_id, stage, dataset, ingest_date, status, started_at_utc)\nSELECT @run_id, @stage, @dataset, @ingest, 'STARTED', SYSUTCDATETIME();\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "BuildSlice_CTAS",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "LogStart",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "-- BuildSlice_CTAS\nDECLARE @ingest_date DATE = '@{pipeline().parameters.run_date}';\n\nIF OBJECT_ID('core.trip_clean_slice') IS NOT NULL\n  DROP TABLE core.trip_clean_slice;\n\nCREATE TABLE core.trip_clean_slice\nWITH (\n  DISTRIBUTION = ROUND_ROBIN,              -- safer since we don't have a reliable hash key\n  CLUSTERED COLUMNSTORE INDEX\n)\nAS\nSELECT\n  UPPER(NULLIF(LTRIM(RTRIM(CAST(s.VendorID AS VARCHAR(32)))), '')) AS vendor_code,\n  CAST(NULL AS BIGINT)                                             AS trip_id,          -- NYC Taxi has no trip_id\n  TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime)                   AS pickup_ts_utc,\n  TRY_CONVERT(DATETIME2, s.tpep_dropoff_datetime)                  AS dropoff_ts_utc,\n  CASE\n    WHEN TRY_CAST(s.trip_distance AS FLOAT) IS NULL THEN NULL\n    ELSE ROUND(TRY_CAST(s.trip_distance AS FLOAT) * 1.609344, 3)\n  END                                                              AS trip_distance_km,\n  TRY_CAST(s.fare_amount AS DECIMAL(9,2))                          AS fare_amount,\n  COALESCE(\n    rp.payment_type_std,\n    CASE TRY_CAST(s.payment_type AS INT)\n      WHEN 1 THEN 'CARD'\n      WHEN 2 THEN 'CASH'\n      WHEN 3 THEN 'NO_CHARGE'\n      WHEN 4 THEN 'DISPUTE'\n    END\n  )                                                                AS payment_type,\n  CASE\n    WHEN TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime) IS NOT NULL\n     AND (DATEPART(HOUR, TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime)) BETWEEN 22 AND 23\n          OR DATEPART(HOUR, TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime)) BETWEEN 0 AND 5)\n    THEN 1 ELSE 0\n  END                                                              AS is_night_ride,\n  s.ingest_date,\n  s.source_file_name,\n  s.loaded_at\nFROM stg.trip AS s\nLEFT JOIN ref.payment_type_map rp\n  ON NULLIF(LTRIM(RTRIM(CAST(s.payment_type AS VARCHAR(50)))), '') = rp.payment_type_src\n AND rp.is_active = 1\nWHERE s.ingest_date = @ingest_date\n  AND TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime) IS NOT NULL\n  AND TRY_CONVERT(DATETIME2, s.tpep_dropoff_datetime) IS NOT NULL\n  AND TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime) <= TRY_CONVERT(DATETIME2, s.tpep_dropoff_datetime)\n  AND TRY_CAST(s.fare_amount AS DECIMAL(9,2)) >= 0\n  AND TRY_CAST(s.trip_distance AS FLOAT) >= 0;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "Quarantine_Rejected",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "BuildSlice_CTAS",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "-- Quarantine_Rejected (idempotent)\nDECLARE @ingest_date DATE = '@{pipeline().parameters.run_date}';\n\n-- NEW: clear prior rejects for this slice so reruns don’t accumulate\nDELETE FROM err.trip WHERE ingest_date = @ingest_date;\n\nINSERT INTO err.trip (\n  ingest_date, source_file_name, loaded_at, reject_reason, raw_payload, recorded_at_utc\n)\nSELECT\n  s.ingest_date,\n  s.source_file_name,\n  s.loaded_at,\n  CASE\n    WHEN TRY_CAST(s.fare_amount AS DECIMAL(9,2)) < 0 THEN 'NEGATIVE_FARE'\n    WHEN TRY_CAST(s.trip_distance AS FLOAT) < 0 THEN 'NEGATIVE_DISTANCE'\n    WHEN TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime) > TRY_CONVERT(DATETIME2, s.tpep_dropoff_datetime) THEN 'PICKUP_AFTER_DROPOFF'\n    WHEN TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime) IS NULL OR TRY_CONVERT(DATETIME2, s.tpep_dropoff_datetime) IS NULL THEN 'NULL_TIME'\n    ELSE 'OTHER_BAD_VALUES'\n  END,\n  CONCAT(\n    'VendorID=', COALESCE(CAST(s.VendorID AS VARCHAR(16)),'NULL'), '; ',\n    'pickup=',  COALESCE(CONVERT(VARCHAR(19), TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime),120),'NULL'), '; ',\n    'dropoff=', COALESCE(CONVERT(VARCHAR(19), TRY_CONVERT(DATETIME2, s.tpep_dropoff_datetime),120),'NULL'), '; ',\n    'fare=',    COALESCE(CAST(s.fare_amount AS VARCHAR(32)),'NULL'), '; ',\n    'dist=',    COALESCE(CAST(s.trip_distance AS VARCHAR(32)),'NULL')\n  ),\n  SYSUTCDATETIME()\nFROM stg.trip s\nWHERE s.ingest_date = @ingest_date\n  AND (\n       TRY_CAST(s.fare_amount AS DECIMAL(9,2)) < 0 OR\n       TRY_CAST(s.trip_distance AS FLOAT) < 0 OR\n       TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime) IS NULL OR\n       TRY_CONVERT(DATETIME2, s.tpep_dropoff_datetime) IS NULL OR\n       TRY_CONVERT(DATETIME2, s.tpep_pickup_datetime) > TRY_CONVERT(DATETIME2, s.tpep_dropoff_datetime)\n  );\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "LoadCore_DedupeAndMetrics",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "Quarantine_Rejected",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "-- LoadCore_DedupeAndMetrics\nDECLARE @ingest_date DATE = '@{pipeline().parameters.run_date}';\n\n-- 1) Idempotent delete of existing partition\nDELETE FROM core.trip_clean WHERE ingest_date = @ingest_date;\n\n-- 2) Deterministic dedupe (compound natural key, since there is no trip_id)\n;WITH ranked AS (\n  SELECT s.*,\n         ROW_NUMBER() OVER (\n           PARTITION BY\n             s.vendor_code,\n             s.pickup_ts_utc,\n             s.dropoff_ts_utc,\n             s.fare_amount,\n             s.trip_distance_km,\n             s.payment_type\n           ORDER BY s.loaded_at DESC, s.source_file_name DESC\n         ) AS rn\n  FROM core.trip_clean_slice s\n  WHERE s.ingest_date = @ingest_date\n)\nINSERT INTO core.trip_clean\n(\n  vendor_code, trip_id, pickup_ts_utc, dropoff_ts_utc,\n  trip_distance_km, fare_amount, payment_type, is_night_ride,\n  ingest_date, source_file_name, loaded_at\n)\nSELECT\n  vendor_code, NULL, pickup_ts_utc, dropoff_ts_utc,\n  trip_distance_km, fare_amount, payment_type, is_night_ride,\n  ingest_date, source_file_name, loaded_at\nFROM ranked\nWHERE rn = 1;\n\n-- Optional: clean up the slice to avoid clutter (keep if no concurrency)\n-- DROP TABLE core.trip_clean_slice;\n\n-- 3) Observability metrics\nINSERT INTO ops.run_metrics (\n  layer, table_name, ingest_date, rows_in, rows_out, rows_err, run_ts_utc, recorded_at_utc\n)\nSELECT\n  'core', 'trip_clean', @ingest_date,\n  (SELECT COUNT(*) FROM stg.trip        WHERE ingest_date = @ingest_date),\n  (SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date = @ingest_date),\n  (SELECT COUNT(*) FROM err.trip        WHERE ingest_date = @ingest_date),\n  SYSUTCDATETIME(), SYSUTCDATETIME();\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "CoreDQ_Gate",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "LoadCore_DedupeAndMetrics",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "-- CoreDQ_Gate: log outcomes to ops.dq_result and fail on hard errors\n\nDECLARE @run_id NVARCHAR(64)  = '@{pipeline().RunId}';\nDECLARE @stage  NVARCHAR(32)  = 'stg_to_core';\nDECLARE @d      DATE          = '@{pipeline().parameters.run_date}';\nDECLARE @now    DATETIME2(3)  = SYSUTCDATETIME();\n\n-- Row counts\nDECLARE @rows_stg   BIGINT = (SELECT COUNT(*) FROM stg.trip        WHERE ingest_date=@d);\nDECLARE @rows_core  BIGINT = (SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date=@d);\nDECLARE @rows_err   BIGINT = (SELECT COUNT(*) FROM err.trip        WHERE ingest_date=@d);\n\n-- Core consistency checks\nDECLARE @bad_time BIGINT =\n(SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date=@d AND pickup_ts_utc > dropoff_ts_utc);\n\nDECLARE @neg_fare BIGINT =\n(SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date=@d AND fare_amount < 0);\n\nDECLARE @neg_dist BIGINT =\n(SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date=@d AND trip_distance_km < 0);\n\nDECLARE @null_pickup BIGINT =\n(SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date=@d AND pickup_ts_utc IS NULL);\n\nDECLARE @null_dropoff BIGINT =\n(SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date=@d AND dropoff_ts_utc IS NULL);\n\n-- Duplicates in core after dedupe (should be zero)\nDECLARE @dupe_core BIGINT =\n(\n  SELECT COUNT(*) FROM (\n    SELECT vendor_code, pickup_ts_utc, dropoff_ts_utc, fare_amount, trip_distance_km, payment_type\n    FROM core.trip_clean\n    WHERE ingest_date=@d\n    GROUP BY vendor_code, pickup_ts_utc, dropoff_ts_utc, fare_amount, trip_distance_km, payment_type\n    HAVING COUNT(*) > 1\n  ) d\n);\n\n-- Core+Err should never exceed staging for a slice\nDECLARE @core_plus_err_gt_stg BIT =\n  CASE WHEN @rows_err IS NULL THEN 0\n       WHEN (@rows_core + @rows_err) > @rows_stg THEN 1 ELSE 0 END;\n\n-- Avoid duplicate log rows for retries/reruns of the same run_id\nDELETE FROM ops.dq_result WHERE run_id=@run_id AND stage=@stage AND ingest_date=@d;\n\n-- Log all outcomes (PASSED/FAILED)\nINSERT INTO ops.dq_result\n(run_id, stage, check_name, ingest_date, status, actual_value, threshold_value, error_message, created_at_utc)\nSELECT @run_id, @stage, 'rowcount_core_gt_0', @d,\n       CASE WHEN @rows_core > 0 THEN 'PASSED' ELSE 'FAILED' END,\n       @rows_core, 1, NULL, @now\nUNION ALL\nSELECT @run_id, @stage, 'no_bad_time_order', @d,\n       CASE WHEN @bad_time = 0 THEN 'PASSED' ELSE 'FAILED' END,\n       @bad_time, 0, NULL, @now\nUNION ALL\nSELECT @run_id, @stage, 'no_negative_fare', @d,\n       CASE WHEN @neg_fare = 0 THEN 'PASSED' ELSE 'FAILED' END,\n       @neg_fare, 0, NULL, @now\nUNION ALL\nSELECT @run_id, @stage, 'no_negative_distance', @d,\n       CASE WHEN @neg_dist = 0 THEN 'PASSED' ELSE 'FAILED' END,\n       @neg_dist, 0, NULL, @now\nUNION ALL\nSELECT @run_id, @stage, 'no_null_pickup_ts', @d,\n       CASE WHEN @null_pickup = 0 THEN 'PASSED' ELSE 'FAILED' END,\n       @null_pickup, 0, NULL, @now\nUNION ALL\nSELECT @run_id, @stage, 'no_null_dropoff_ts', @d,\n       CASE WHEN @null_dropoff = 0 THEN 'PASSED' ELSE 'FAILED' END,\n       @null_dropoff, 0, NULL, @now\nUNION ALL\nSELECT @run_id, @stage, 'no_duplicate_core_rows', @d,\n       CASE WHEN @dupe_core = 0 THEN 'PASSED' ELSE 'FAILED' END,\n       @dupe_core, 0, NULL, @now\nUNION ALL\nSELECT @run_id, @stage, 'core_plus_err_le_stg', @d,\n       CASE WHEN @core_plus_err_gt_stg = 0 THEN 'PASSED' ELSE 'FAILED' END,\n       (@rows_core + @rows_err) - @rows_stg, 0, NULL, @now;\n\n-- Hard fail if any FAILED status exists for this run/date\nIF EXISTS (\n  SELECT 1 FROM ops.dq_result\n  WHERE run_id=@run_id AND stage=@stage AND ingest_date=@d AND status='FAILED'\n)\n  THROW 53000, 'DQ FAIL: One or more core checks failed. See ops.dq_result for details.', 1;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "LogSuccess",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "CoreDQ_Gate",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "-- LogSuccess (after CoreDQ_Gate succeeds)\nDECLARE @run_id   NVARCHAR(64)  = '@{pipeline().RunId}';\nDECLARE @stage    NVARCHAR(32)  = 'stg_to_core';\nDECLARE @dataset  NVARCHAR(128) = '@{pipeline().parameters.dataset}';\nDECLARE @d        DATE          = '@{pipeline().parameters.run_date}';\n\nDECLARE @rows BIGINT = (SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date = @d);\n\n-- Try to update existing STARTED row\nUPDATE ops.run_log\nSET status = 'SUCCEEDED',\n    rows_copied = @rows,\n    finished_at_utc = CAST(SYSUTCDATETIME() AS DATETIME2(3))\nWHERE run_id = @run_id\n  AND stage  = @stage;\n\n-- Fallback if no row exists (avoid @@ROWCOUNT)\nIF NOT EXISTS (SELECT 1 FROM ops.run_log WHERE run_id = @run_id AND stage = @stage)\nBEGIN\n  INSERT INTO ops.run_log\n    (run_id, stage, dataset, ingest_date, status, started_at_utc, finished_at_utc, rows_copied)\n  SELECT\n    @run_id, @stage, @dataset, @d, 'SUCCEEDED',\n    CAST(SYSUTCDATETIME() AS DATETIME2(3)),\n    CAST(SYSUTCDATETIME() AS DATETIME2(3)),\n    @rows;\nEND\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "LogFailure",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "CoreDQ_Gate",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "-- LogFailure (after CoreDQ_Gate fails)\nDECLARE @run_id   NVARCHAR(64)  = '@{pipeline().RunId}';\nDECLARE @stage    NVARCHAR(32)  = 'stg_to_core';\nDECLARE @dataset  NVARCHAR(128) = '@{pipeline().parameters.dataset}';\nDECLARE @d        DATE          = '@{pipeline().parameters.run_date}';\n\nDECLARE @rows BIGINT = (SELECT COUNT(*) FROM core.trip_clean WHERE ingest_date = @d);\n\n-- Try to update existing STARTED row\nUPDATE ops.run_log\nSET status = 'FAILED',\n    rows_copied = @rows,\n    finished_at_utc = CAST(SYSUTCDATETIME() AS DATETIME2(3))\nWHERE run_id = @run_id\n  AND stage  = @stage;\n\n-- Fallback if no row exists (avoid @@ROWCOUNT)\nIF NOT EXISTS (SELECT 1 FROM ops.run_log WHERE run_id = @run_id AND stage = @stage)\nBEGIN\n  INSERT INTO ops.run_log\n    (run_id, stage, dataset, ingest_date, status, started_at_utc, finished_at_utc, rows_copied)\n  SELECT\n    @run_id, @stage, @dataset, @d, 'FAILED',\n    CAST(SYSUTCDATETIME() AS DATETIME2(3)),\n    CAST(SYSUTCDATETIME() AS DATETIME2(3)),\n    @rows;\nEND\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"dataset": {
						"type": "string",
						"defaultValue": "nyctaxi_yellow"
					},
					"run_date": {
						"type": "string",
						"defaultValue": "@{formatDateTime(utcNow(),'yyyy-MM-dd')}"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_syn_sql')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_curated_csv')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_storage_curated",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "-1277435299_f5f3bba8954e442881824a2b1a78e38f_1.csv",
						"folderPath": "date=2025/09/29/17",
						"container": "streaming-curated"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": false,
					"quoteChar": "\""
				},
				"schema": [
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_curated')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_curated_folder')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_storage_curated",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"dir": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"folderPath": {
							"value": "@dataset().dir",
							"type": "Expression"
						},
						"container": "streaming-curated"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_curated')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_raw_folder_adf')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_adls_raw_adf",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"p_dataset": {
						"type": "string"
					},
					"p_run_date": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@concat(dataset().p_dataset,'/ingest_date=',dataset().p_run_date)",
							"type": "Expression"
						},
						"fileSystem": "raw"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_adls_raw_adf')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_raw_parquet_adf')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_adls_raw_adf",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"p_dataset": {
						"type": "string"
					},
					"p_run_date": {
						"type": "string"
					},
					"p_file_name": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().p_file_name",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@concat(dataset().p_dataset,'/ingest_date=',dataset().p_run_date)",
							"type": "Expression"
						},
						"fileSystem": "raw"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_adls_raw_adf')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_syn_stg_trip_adf')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_syn_sql",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlDWTable",
				"schema": [],
				"typeProperties": {
					"schema": "stg",
					"table": "trip"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_syn_sql')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_trips_stg')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_syn_sql",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlDWTable",
				"schema": [
					{
						"name": "schemaVersion",
						"type": "nvarchar"
					},
					{
						"name": "eventId",
						"type": "nvarchar"
					},
					{
						"name": "tpepPickupDatetime",
						"type": "datetime2",
						"scale": 3
					},
					{
						"name": "tpepDropoffDatetime",
						"type": "datetime2",
						"scale": 3
					},
					{
						"name": "vendorId",
						"type": "nvarchar"
					},
					{
						"name": "passengerCount",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "tripDistance",
						"type": "float",
						"precision": 15
					},
					{
						"name": "puLocationId",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "doLocationId",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "fareAmount",
						"type": "float",
						"precision": 15
					},
					{
						"name": "tipAmount",
						"type": "float",
						"precision": 15
					},
					{
						"name": "tollsAmount",
						"type": "float",
						"precision": 15
					},
					{
						"name": "improvementSurcharge",
						"type": "float",
						"precision": 15
					},
					{
						"name": "mtaTax",
						"type": "float",
						"precision": 15
					},
					{
						"name": "extra",
						"type": "float",
						"precision": 15
					},
					{
						"name": "totalAmount",
						"type": "float",
						"precision": 15
					},
					{
						"name": "paymentType",
						"type": "nvarchar"
					},
					{
						"name": "source",
						"type": "nvarchar"
					},
					{
						"name": "producerTs",
						"type": "datetime2",
						"scale": 3
					},
					{
						"name": "enqueuedTs",
						"type": "datetime2",
						"scale": 3
					},
					{
						"name": "durationMin",
						"type": "int",
						"precision": 10
					},
					{
						"name": "_ingestedAt",
						"type": "datetime2",
						"scale": 3
					},
					{
						"name": "_blobPath",
						"type": "nvarchar"
					},
					{
						"name": "_runId",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "stg",
					"table": "TripsStreaming"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_syn_sql')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_raw_to_stg_nyctaxi')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "DeleteStagingPartition",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "LogTheRun",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DELETE FROM stg.trip WHERE ingest_date = '@{pipeline().parameters.run_date}';\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "GetFileList",
						"type": "GetMetadata",
						"dependsOn": [
							{
								"activity": "DeleteStagingPartition",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_raw_folder_adf",
								"type": "DatasetReference",
								"parameters": {
									"p_dataset": {
										"value": "@pipeline().parameters.dataset",
										"type": "Expression"
									},
									"p_run_date": {
										"value": "@pipeline().parameters.run_date",
										"type": "Expression"
									}
								}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "BinaryReadSettings"
							}
						}
					},
					{
						"name": "FilterParquet",
						"type": "Filter",
						"dependsOn": [
							{
								"activity": "GetFileList",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('GetFileList').output.childItems",
								"type": "Expression"
							},
							"condition": {
								"value": "@and(equals(item().type,'File'),\n     endsWith(item().name,'.snappy.millis.parquet'))\n",
								"type": "Expression"
							}
						}
					},
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "FilterParquet",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('FilterParquet').output.value",
								"type": "Expression"
							},
							"batchCount": 4,
							"activities": [
								{
									"name": "IfNeedsSnappy",
									"type": "IfCondition",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@not(endsWith(item().name,'.snappy.millis.parquet'))",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "ConvertToSnappy",
												"type": "SynapseNotebook",
												"dependsOn": [],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"notebook": {
														"referenceName": {
															"value": "nb_convert_parquet_to_snappy",
															"type": "Expression"
														},
														"type": "NotebookReference"
													},
													"parameters": {
														"account": {
															"value": "eltazr3adls",
															"type": "string"
														},
														"file_system": {
															"value": "raw",
															"type": "string"
														},
														"dataset": {
															"value": {
																"value": "@pipeline().parameters.dataset",
																"type": "Expression"
															},
															"type": "string"
														},
														"ingest_date": {
															"value": {
																"value": "@pipeline().parameters.run_date",
																"type": "Expression"
															},
															"type": "string"
														},
														"src_file_name": {
															"value": {
																"value": "@item().name",
																"type": "Expression"
															},
															"type": "string"
														},
														"tgt_file_name": {
															"value": {
																"value": "@replace(item().name, '.parquet', '.snappy.millis.parquet')",
																"type": "Expression"
															},
															"type": "string"
														}
													},
													"snapshot": true,
													"sparkPool": {
														"referenceName": {
															"value": "spsmall",
															"type": "Expression"
														},
														"type": "BigDataPoolReference"
													},
													"executorSize": "Small",
													"conf": {
														"spark.dynamicAllocation.enabled": null,
														"spark.dynamicAllocation.minExecutors": null,
														"spark.dynamicAllocation.maxExecutors": null
													},
													"driverSize": "Small",
													"numExecutors": null
												},
												"linkedServiceName": {
													"referenceName": "AzureSynapseArtifacts2",
													"type": "LinkedServiceReference"
												}
											}
										]
									}
								},
								{
									"name": "CopyToStaging_copy1",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "IfNeedsSnappy",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "ParquetSource",
											"additionalColumns": [
												{
													"name": "ingest_date",
													"value": {
														"value": "@{pipeline().parameters.run_date}",
														"type": "Expression"
													}
												},
												{
													"name": "source_file_name",
													"value": {
														"value": "@{item().name}",
														"type": "Expression"
													}
												},
												{
													"name": "loaded_at",
													"value": {
														"value": "@{utcnow()}",
														"type": "Expression"
													}
												}
											],
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "ParquetReadSettings"
											}
										},
										"sink": {
											"type": "SqlDWSink",
											"writeBehavior": "Insert"
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"name": "VendorID",
														"type": "Int32"
													},
													"sink": {
														"name": "VendorID",
														"type": "Int16"
													}
												},
												{
													"source": {
														"name": "tpep_pickup_datetime",
														"type": "String"
													},
													"sink": {
														"name": "tpep_pickup_datetime",
														"type": "DateTime"
													}
												},
												{
													"source": {
														"name": "tpep_dropoff_datetime",
														"type": "String"
													},
													"sink": {
														"name": "tpep_dropoff_datetime",
														"type": "DateTime"
													}
												},
												{
													"source": {
														"name": "passenger_count",
														"type": "Int64"
													},
													"sink": {
														"name": "passenger_count",
														"type": "Int16"
													}
												},
												{
													"source": {
														"name": "trip_distance",
														"type": "Double"
													},
													"sink": {
														"name": "trip_distance",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "RatecodeID",
														"type": "Int64"
													},
													"sink": {
														"name": "RatecodeID",
														"type": "Int16"
													}
												},
												{
													"source": {
														"name": "store_and_fwd_flag",
														"type": "String"
													},
													"sink": {
														"name": "store_and_fwd_flag",
														"type": "String"
													}
												},
												{
													"source": {
														"name": "PULocationID",
														"type": "Int32"
													},
													"sink": {
														"name": "PULocationID",
														"type": "Int16"
													}
												},
												{
													"source": {
														"name": "DOLocationID",
														"type": "Int32"
													},
													"sink": {
														"name": "DOLocationID",
														"type": "Int16"
													}
												},
												{
													"source": {
														"name": "payment_type",
														"type": "Int64"
													},
													"sink": {
														"name": "payment_type",
														"type": "Int16"
													}
												},
												{
													"source": {
														"name": "fare_amount",
														"type": "Double"
													},
													"sink": {
														"name": "fare_amount",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "extra",
														"type": "Double"
													},
													"sink": {
														"name": "extra",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "mta_tax",
														"type": "Double"
													},
													"sink": {
														"name": "mta_tax",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "tip_amount",
														"type": "Double"
													},
													"sink": {
														"name": "tip_amount",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "tolls_amount",
														"type": "Double"
													},
													"sink": {
														"name": "tolls_amount",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "improvement_surcharge",
														"type": "Double"
													},
													"sink": {
														"name": "improvement_surcharge",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "total_amount",
														"type": "Double"
													},
													"sink": {
														"name": "total_amount",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "congestion_surcharge",
														"type": "Double"
													},
													"sink": {
														"name": "congestion_surcharge",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "Airport_fee",
														"type": "Double"
													},
													"sink": {
														"name": "airport_fee",
														"type": "Decimal"
													}
												},
												{
													"source": {
														"name": "ingest_date",
														"type": "String"
													},
													"sink": {
														"name": "ingest_date",
														"type": "Date"
													}
												},
												{
													"source": {
														"name": "source_file_name",
														"type": "String"
													},
													"sink": {
														"name": "source_file_name",
														"type": "String"
													}
												},
												{
													"source": {
														"name": "loaded_at",
														"type": "String"
													},
													"sink": {
														"name": "loaded_at",
														"type": "DateTime"
													}
												}
											],
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "ds_raw_parquet_adf",
											"type": "DatasetReference",
											"parameters": {
												"p_dataset": "@pipeline().parameters.dataset",
												"p_run_date": "@pipeline().parameters.run_date",
												"p_file_name": "@item().name"
											}
										}
									],
									"outputs": [
										{
											"referenceName": "ds_syn_stg_trip_adf",
											"type": "DatasetReference",
											"parameters": {}
										}
									]
								},
								{
									"name": "DQ_Rowcount",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "CopyToStaging_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_syn_sql",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"type": "Query",
												"text": {
													"value": "DECLARE @run_id NVARCHAR(64)='@{pipeline().RunId}';\nDECLARE @stage  NVARCHAR(32)='raw_to_stg';\nDECLARE @d      DATE='@{pipeline().parameters.run_date}';\nDECLARE @now    DATETIME2(3)=SYSUTCDATETIME();\nDECLARE @cnt    BIGINT;\nDECLARE @status NVARCHAR(16);\n\nSELECT @cnt = COUNT(*) FROM stg.trip WHERE ingest_date=@d;\nSET @status = CASE WHEN @cnt>0 THEN 'PASSED' ELSE 'FAILED' END;\n\nINSERT INTO ops.dq_result (run_id,stage,check_name,ingest_date,status,actual_value,threshold_value,error_message,created_at_utc)\nSELECT @run_id,@stage,'rowcount_gt_0',@d,@status,@cnt,1,NULL,@now;\n\nIF @cnt = 0\n  THROW 51000, 'DQ Rowcount failed: 0 rows loaded for ingest_date', 1;\n",
													"type": "Expression"
												}
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								},
								{
									"name": "DQ_NullPickup",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "DQ_Rowcount",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_syn_sql",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"type": "Query",
												"text": {
													"value": "DECLARE @run_id NVARCHAR(64)='@{pipeline().RunId}';\nDECLARE @stage  NVARCHAR(32)='raw_to_stg';\nDECLARE @d      DATE='@{pipeline().parameters.run_date}';\nDECLARE @now    DATETIME2(3)=SYSUTCDATETIME();\nDECLARE @bad    BIGINT;\nDECLARE @status NVARCHAR(16);\n\nSELECT @bad = COUNT(*) FROM stg.trip WHERE ingest_date=@d AND tpep_pickup_datetime IS NULL;\nSET @status = CASE WHEN @bad=0 THEN 'PASSED' ELSE 'FAILED' END;\n\nINSERT INTO ops.dq_result (run_id,stage,check_name,ingest_date,status,actual_value,threshold_value,error_message,created_at_utc)\nSELECT @run_id,@stage,'no_null_pickup_ts',@d,@status,@bad,0,NULL,@now;\n\nIF @bad > 0\n  THROW 51001, 'DQ Null pickup datetime failed', 1;\n",
													"type": "Expression"
												}
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								},
								{
									"name": "DQ_NegativeFare",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "DQ_NullPickup",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_syn_sql",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"type": "Query",
												"text": {
													"value": "DECLARE @run_id NVARCHAR(64)='@{pipeline().RunId}';\nDECLARE @stage  NVARCHAR(32)='raw_to_stg';\nDECLARE @d      DATE='@{pipeline().parameters.run_date}';\nDECLARE @now    DATETIME2(3)=SYSUTCDATETIME();\nDECLARE @neg    BIGINT;\nDECLARE @status NVARCHAR(16);\n\nSELECT @neg = COUNT(*) FROM stg.trip WHERE ingest_date=@d AND fare_amount < 0;\nSET @status = CASE WHEN @neg=0 THEN 'PASSED' ELSE 'WARNING' END;\n\nINSERT INTO ops.dq_result (run_id,stage,check_name,ingest_date,status,actual_value,threshold_value,error_message,created_at_utc)\nSELECT @run_id,@stage,'no_negative_fare',@d,@status,@neg,0,NULL,@now;\n\n/* No THROW here – we only log and proceed */\n",
													"type": "Expression"
												}
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								}
							]
						}
					},
					{
						"name": "LogTheRun",
						"type": "Script",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @run_id     NVARCHAR(64)  = '@{pipeline().RunId}';\nDECLARE @stage      NVARCHAR(32)  = 'raw_to_stg';\nDECLARE @dataset    NVARCHAR(128) = '@{pipeline().parameters.dataset}';\n--DECLARE @ingest     DATE          = '@{pipeline().parameters.run_date}';\n\nDECLARE @ingest_date_str NVARCHAR(32) = '@{pipeline().parameters.run_date}';\nDECLARE @ingest DATE = TRY_CONVERT(DATE, @ingest_date_str, 23);\nIF @ingest IS NULL\n  THROW 53001, 'Bad run_date format. Expected yyyy-MM-dd.', 1;\n\nDECLARE @started    DATETIME2(3)  = SYSUTCDATETIME();\n\nINSERT INTO ops.run_log(run_id, stage, dataset, ingest_date, status, started_at_utc)\nVALUES (@run_id, @stage, @dataset, @ingest, 'STARTED', @started);\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "UpdateTheLogWithSuccess",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "ForEach1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @run_id    NVARCHAR(64)  = '@{pipeline().RunId}';\nDECLARE @stage     NVARCHAR(32)  = 'raw_to_stg';\nDECLARE @ingest    DATE          = '@{pipeline().parameters.run_date}';\nDECLARE @rows      BIGINT        = (SELECT COUNT(*) FROM stg.trip WHERE ingest_date = @ingest);\nDECLARE @finished  DATETIME2(3)  = SYSUTCDATETIME();\n\nUPDATE ops.run_log\nSET status = 'SUCCEEDED',\n    rows_copied = @rows,\n    finished_at_utc = @finished\nWHERE run_id = @run_id AND stage = @stage;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "UpdateTheLogWithFailure",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "ForEach1",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @run_id    NVARCHAR(64)  = '@{pipeline().RunId}';\nDECLARE @stage     NVARCHAR(32)  = 'raw_to_stg';\nDECLARE @ingest    DATE          = '@{pipeline().parameters.run_date}';\nDECLARE @rows      BIGINT        = (SELECT COUNT(*) FROM stg.trip WHERE ingest_date = @ingest);\nDECLARE @finished  DATETIME2(3)  = SYSUTCDATETIME();\n\nUPDATE ops.run_log\nSET status = 'FAILED',\n    rows_copied = @rows,\n    finished_at_utc = @finished\nWHERE run_id = @run_id AND stage = @stage;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"dataset": {
						"type": "string",
						"defaultValue": "nyctaxi_yellow"
					},
					"run_date": {
						"type": "string",
						"defaultValue": "@formatDateTime(utcnow(),'yyyy-MM-dd')"
					},
					"file_name": {
						"type": "string"
					},
					"run_id": {
						"type": "string",
						"defaultValue": "@pipeline().RunId"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_syn_sql')]",
				"[concat(variables('factoryId'), '/datasets/ds_raw_folder_adf')]",
				"[concat(variables('factoryId'), '/datasets/ds_raw_parquet_adf')]",
				"[concat(variables('factoryId'), '/datasets/ds_syn_stg_trip_adf')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureSynapseArtifacts2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_streaming_curated_to_stg_core_mdl')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "ForEachFile",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "IfHourExists",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('files')",
								"type": "Expression"
							},
							"batchCount": 4,
							"activities": [
								{
									"name": "DeleteExisting",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[stg].[usp_delete_trips_by_blob]",
										"storedProcedureParameters": {
											"blobPath": {
												"value": {
													"value": "@concat('streaming-curated/', variables('hourPath'), '/', item())",
													"type": "Expression"
												},
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_syn_sql",
										"type": "LinkedServiceReference"
									}
								},
								{
									"name": "CopyCuratedToStg",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "DeleteExisting",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"additionalColumns": [
												{
													"name": "_runId",
													"value": {
														"value": "@pipeline().RunId",
														"type": "Expression"
													}
												},
												{
													"name": "_blobPath",
													"value": {
														"value": "@concat('streaming-curated/', variables('hourPath'), '/', item())",
														"type": "Expression"
													}
												},
												{
													"name": "_ingestedAt",
													"value": {
														"value": "@utcnow()",
														"type": "Expression"
													}
												}
											],
											"storeSettings": {
												"type": "AzureBlobStorageReadSettings",
												"recursive": false,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings",
												"skipLineCount": 1
											}
										},
										"sink": {
											"type": "SqlDWSink",
											"writeBehavior": "Insert",
											"sqlWriterUseTableLock": false
										},
										"enableStaging": true,
										"stagingSettings": {
											"linkedServiceName": {
												"referenceName": "ls_storage_curated",
												"type": "LinkedServiceReference"
											},
											"path": "adf-staging"
										},
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"type": "String",
														"ordinal": 1
													},
													"sink": {
														"name": "schemaVersion",
														"type": "String",
														"physicalType": "nvarchar"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 2
													},
													"sink": {
														"name": "eventId",
														"type": "String",
														"physicalType": "nvarchar"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 3
													},
													"sink": {
														"name": "tpepPickupDatetime",
														"type": "DateTime",
														"physicalType": "datetime2"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 4
													},
													"sink": {
														"name": "tpepDropoffDatetime",
														"type": "DateTime",
														"physicalType": "datetime2"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 5
													},
													"sink": {
														"name": "vendorId",
														"type": "String",
														"physicalType": "nvarchar"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 6
													},
													"sink": {
														"name": "passengerCount",
														"type": "Int64",
														"physicalType": "bigint"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 7
													},
													"sink": {
														"name": "tripDistance",
														"type": "Double",
														"physicalType": "float"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 8
													},
													"sink": {
														"name": "puLocationId",
														"type": "Int64",
														"physicalType": "bigint"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 9
													},
													"sink": {
														"name": "doLocationId",
														"type": "Int64",
														"physicalType": "bigint"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 10
													},
													"sink": {
														"name": "fareAmount",
														"type": "Double",
														"physicalType": "float"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 11
													},
													"sink": {
														"name": "tipAmount",
														"type": "Double",
														"physicalType": "float"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 12
													},
													"sink": {
														"name": "tollsAmount",
														"type": "Double",
														"physicalType": "float"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 13
													},
													"sink": {
														"name": "improvementSurcharge",
														"type": "Double",
														"physicalType": "float"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 14
													},
													"sink": {
														"name": "mtaTax",
														"type": "Double",
														"physicalType": "float"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 15
													},
													"sink": {
														"name": "extra",
														"type": "Double",
														"physicalType": "float"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 16
													},
													"sink": {
														"name": "totalAmount",
														"type": "Double",
														"physicalType": "float"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 17
													},
													"sink": {
														"name": "paymentType",
														"type": "String",
														"physicalType": "nvarchar"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 18
													},
													"sink": {
														"name": "source",
														"type": "String",
														"physicalType": "nvarchar"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 19
													},
													"sink": {
														"name": "producerTs",
														"type": "DateTime",
														"physicalType": "datetime2"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 20
													},
													"sink": {
														"name": "enqueuedTs",
														"type": "DateTime",
														"physicalType": "datetime2"
													}
												},
												{
													"source": {
														"type": "String",
														"ordinal": 21
													},
													"sink": {
														"name": "durationMin",
														"type": "Int32",
														"physicalType": "int"
													}
												},
												{
													"source": {
														"name": "_runId",
														"type": "String"
													},
													"sink": {
														"name": "_runId",
														"type": "String",
														"physicalType": "nvarchar"
													}
												},
												{
													"source": {
														"name": "_blobPath",
														"type": "String"
													},
													"sink": {
														"name": "_blobPath",
														"type": "String",
														"physicalType": "nvarchar"
													}
												},
												{
													"source": {
														"name": "_ingestedAt",
														"type": "String"
													},
													"sink": {
														"name": "_ingestedAt",
														"type": "DateTime",
														"physicalType": "datetime2"
													}
												}
											],
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "ds_curated_csv",
											"type": "DatasetReference",
											"parameters": {}
										}
									],
									"outputs": [
										{
											"referenceName": "ds_trips_stg",
											"type": "DatasetReference",
											"parameters": {}
										}
									]
								},
								{
									"name": "LogSuccess",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [
										{
											"activity": "CopyCuratedToStg",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[stg].[usp_log_ingest]",
										"storedProcedureParameters": {
											"blobPath": {
												"value": {
													"value": "@concat('streaming-curated/', variables('hourPath'), '/', item())",
													"type": "Expression"
												},
												"type": "String"
											},
											"message": {
												"value": " ",
												"type": "String"
											},
											"rowsCopied": {
												"value": {
													"value": "@coalesce(activity('CopyCuratedToStg').output.rowsCopied, 0)",
													"type": "Expression"
												},
												"type": "Int64"
											},
											"runId": {
												"value": {
													"value": "@pipeline().RunId",
													"type": "Expression"
												},
												"type": "String"
											},
											"status": {
												"value": "Success",
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_syn_sql",
										"type": "LinkedServiceReference"
									}
								},
								{
									"name": "LogFailure",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [
										{
											"activity": "CopyCuratedToStg",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[stg].[usp_log_ingest]",
										"storedProcedureParameters": {
											"blobPath": {
												"value": {
													"value": "@concat('streaming-curated/', variables('hourPath'), '/', item())",
													"type": "Expression"
												},
												"type": "String"
											},
											"message": {
												"value": {
													"value": "@string(activity('CopyCuratedToStg').error.message)",
													"type": "Expression"
												},
												"type": "String"
											},
											"rowsCopied": {
												"value": "0",
												"type": "Int64"
											},
											"runId": {
												"value": {
													"value": "@pipeline().RunId",
													"type": "Expression"
												},
												"type": "String"
											},
											"status": {
												"value": "Failure",
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_syn_sql",
										"type": "LinkedServiceReference"
									}
								},
								{
									"name": "LogDeleteFailure",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [
										{
											"activity": "DeleteExisting",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[stg].[usp_log_ingest]",
										"storedProcedureParameters": {
											"blobPath": {
												"value": {
													"value": "@concat('streaming-curated/', variables('hourPath'), '/', item())",
													"type": "Expression"
												},
												"type": "String"
											},
											"message": {
												"value": {
													"value": "@string(activity('DeleteExisting').error.message)",
													"type": "Expression"
												},
												"type": "String"
											},
											"rowsCopied": {
												"value": "0",
												"type": "Int64"
											},
											"runId": {
												"value": {
													"value": "@pipeline().RunId",
													"type": "Expression"
												},
												"type": "String"
											},
											"status": {
												"value": "Failure",
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "ls_syn_sql",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					},
					{
						"name": "SetHourPath",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "hourPath",
							"value": {
								"value": "@formatDateTime(\n    coalesce(pipeline().parameters.fixedHourUtc, formatDateTime(addHours(utcNow(), -1), 'yyyy-MM-ddTHH:00:00Z')),\n    'yyyy/MM/dd/HH'\n)\n",
								"type": "Expression"
							}
						}
					},
					{
						"name": "CheckHourFolder",
						"type": "GetMetadata",
						"dependsOn": [
							{
								"activity": "SetHourPath",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_curated_folder",
								"type": "DatasetReference",
								"parameters": {
									"dir": "@variables('hourPath')"
								}
							},
							"fieldList": [
								"exists"
							],
							"storeSettings": {
								"type": "AzureBlobStorageReadSettings",
								"recursive": true,
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "BinaryReadSettings"
							}
						}
					},
					{
						"name": "IfHourExists",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "CheckHourFolder",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(activity('CheckHourFolder').output.exists, true)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "SetFilesEmpty",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "files",
										"value": [
											"@json('[]')"
										]
									}
								}
							],
							"ifTrueActivities": [
								{
									"name": "GetFiles",
									"type": "GetMetadata",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_curated_folder",
											"type": "DatasetReference",
											"parameters": {
												"dir": "@variables('hourPath')"
											}
										},
										"fieldList": [
											"childItems"
										],
										"storeSettings": {
											"type": "AzureBlobStorageReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										},
										"formatSettings": {
											"type": "BinaryReadSettings"
										}
									}
								},
								{
									"name": "SetFiles",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "GetFiles",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "files",
										"value": {
											"value": "@coalesce(activity('GetFiles').output.childItems, json('[]'))",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "BuildSliceFromStaging",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "ForEachFile",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[core].[usp_build_trip_clean_slice_streaming]",
							"storedProcedureParameters": {
								"runId": {
									"value": {
										"value": "@pipeline().RunId",
										"type": "Expression"
									},
									"type": "String"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "UpsertCleanFromSlice",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "BuildSliceFromStaging",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[core].[usp_upsert_trip_clean_from_slice_streaming]",
							"storedProcedureParameters": {
								"runId": {
									"value": {
										"value": "@pipeline().RunId",
										"type": "Expression"
									},
									"type": "String"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "UpsertDimsFromSlice",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "UpsertCleanFromSlice",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[mdl].[usp_upsert_dims_from_slice_streaming]",
							"storedProcedureParameters": {
								"runId": {
									"value": {
										"value": "@pipeline().RunId",
										"type": "Expression"
									},
									"type": "String"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "PurgeSliceForRun",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "UpsertFactFromSlice",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[core].[usp_purge_trip_clean_slice_streaming]",
							"storedProcedureParameters": {
								"deleted": {
									"value": "0",
									"type": "Int32"
								},
								"runId": {
									"value": {
										"value": "@pipeline().RunId",
										"type": "Expression"
									},
									"type": "String"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "LogSuccess_copy1",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "PurgeSliceForRun",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[stg].[usp_log_ingest]",
							"storedProcedureParameters": {
								"blobPath": {
									"value": {
										"value": "model/fact_trip",
										"type": "Expression"
									},
									"type": "String"
								},
								"message": {
									"value": {
										"value": "@string(concat('i=', activity('UpsertFactFromSlice').output.resultSets[0].rows[0].Inserted, ', u=', activity('UpsertFactFromSlice').output.resultSets[0].rows[0].Updated))",
										"type": "Expression"
									},
									"type": "String"
								},
								"rowsCopied": {
									"value": {
										"value": "@coalesce(activity('UpsertFactFromSlice').output.resultSets[0].rows[0].Total, 0)",
										"type": "Expression"
									},
									"type": "Int64"
								},
								"runId": {
									"value": {
										"value": "@pipeline().RunId",
										"type": "Expression"
									},
									"type": "String"
								},
								"status": {
									"value": "Success",
									"type": "String"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "LogFailure_copy1",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [
							{
								"activity": "PurgeSliceForRun",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[stg].[usp_log_ingest]",
							"storedProcedureParameters": {
								"blobPath": {
									"value": {
										"value": "model\\fact_trip",
										"type": "Expression"
									},
									"type": "String"
								},
								"message": {
									"value": {
										"value": "@string(concat(\n    'activity=UpsertFactFromSlice; failureType=',\n    activity('UpsertFactFromSlice').error.failureType,\n    '; errorCode=', activity('UpsertFactFromSlice').error.errorCode,\n    '; message=', activity('UpsertFactFromSlice').error.message\n))\n",
										"type": "Expression"
									},
									"type": "String"
								},
								"rowsCopied": {
									"value": "0",
									"type": "Int64"
								},
								"runId": {
									"value": {
										"value": "@pipeline().RunId",
										"type": "Expression"
									},
									"type": "String"
								},
								"status": {
									"value": "Failure",
									"type": "String"
								}
							}
						},
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						}
					},
					{
						"name": "UpsertFactFromSlice",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "UpsertDimsFromSlice",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_syn_sql",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "DECLARE @i INT, @u INT, @t INT;\nEXEC mdl.usp_upsert_fact_trip_streaming\n  @runId    = N'@{pipeline().RunId}',\n  @inserted = @i OUTPUT,\n  @updated  = @u OUTPUT,\n  @total    = @t OUTPUT;\n\nSELECT Inserted = @i, Updated = @u, Total = @t;\n",
										"type": "Expression"
									}
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"curatedContainer": {
						"type": "string",
						"defaultValue": "streaming-curated"
					},
					"curatedPrefix": {
						"type": "string",
						"defaultValue": "streaming-curated"
					},
					"processMode": {
						"type": "string",
						"defaultValue": "lastHour"
					},
					"fixedHourUtc": {
						"type": "string"
					}
				},
				"variables": {
					"year": {
						"type": "String"
					},
					"month": {
						"type": "String"
					},
					"day": {
						"type": "String"
					},
					"hour": {
						"type": "String"
					},
					"hourPath": {
						"type": "String"
					},
					"files": {
						"type": "Array"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_curated_folder')]",
				"[concat(variables('factoryId'), '/linkedServices/ls_syn_sql')]",
				"[concat(variables('factoryId'), '/datasets/ds_curated_csv')]",
				"[concat(variables('factoryId'), '/datasets/ds_trips_stg')]",
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_curated')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_daily_nyctaxi')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Run_RawToStg",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_raw_to_stg_nyctaxi",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"dataset": {
									"value": "@pipeline().parameters.dataset",
									"type": "Expression"
								},
								"run_date": {
									"value": "@pipeline().parameters.run_date",
									"type": "Expression"
								},
								"run_id": {
									"value": "@pipeline().RunId",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "Run_StgToCore",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Run_RawToStg",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stg_to_core_nyctaxi",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"dataset": {
									"value": "@pipeline().parameters.dataset",
									"type": "Expression"
								},
								"run_date": {
									"value": "@pipeline().parameters.run_date",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "Run_CoreToMdl",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Run_StgToCore",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_core_to_mdl_nyctaxi",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"dataset": {
									"value": "@pipeline().parameters.dataset",
									"type": "Expression"
								},
								"run_date": {
									"value": "@pipeline().parameters.run_date",
									"type": "Expression"
								}
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"dataset": {
						"type": "string",
						"defaultValue": "nyctaxi_yellow"
					},
					"run_date": {
						"type": "string",
						"defaultValue": "@{formatDateTime(utcNow(),'yyyy-MM-dd')}"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_raw_to_stg_nyctaxi')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stg_to_core_nyctaxi')]",
				"[concat(variables('factoryId'), '/pipelines/pl_core_to_mdl_nyctaxi')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_streaming_backfill_range')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "SetcurrentHour",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "currentHour",
							"value": {
								"value": "@formatDateTime(pipeline().parameters.startHourUtc, 'yyyy-MM-ddTHH:00:00Z')\n",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Until1",
						"type": "Until",
						"dependsOn": [
							{
								"activity": "SetcurrentHour",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@greater(variables('currentHour'), pipeline().parameters.endHourUtc)\n",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "ExecuteHour",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"policy": {
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "pl_streaming_curated_to_stg_core_mdl",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"fixedHourUtc": {
												"value": "@variables('currentHour')",
												"type": "Expression"
											}
										}
									}
								},
								{
									"name": "ComputeNextHour",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "ExecuteHour",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "nextHour",
										"value": {
											"value": "@formatDateTime(addHours(variables('currentHour'), 1), 'yyyy-MM-ddTHH:00:00Z')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "AdvanceHour",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "ComputeNextHour",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "currentHour",
										"value": {
											"value": "@variables('nextHour')",
											"type": "Expression"
										}
									}
								}
							],
							"timeout": "0.12:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"startHourUtc": {
						"type": "string"
					},
					"endHourUtc": {
						"type": "string"
					}
				},
				"variables": {
					"currentHour": {
						"type": "String"
					},
					"nextHour": {
						"type": "String"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_streaming_curated_to_stg_core_mdl')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_streaming_backfill')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "IflastHour",
						"type": "IfCondition",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(pipeline().parameters.processMode, 'lastHour')",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "ExecutePipeline_lastHour",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"policy": {
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "pl_streaming_curated_to_stg_core_mdl",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"fixedHourUtc": {
												"value": "@pipeline().parameters.fixedHourUtc",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					},
					{
						"name": "IffixedHour",
						"type": "IfCondition",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(pipeline().parameters.processMode, 'fixedHour')",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "ExecutePipeline_fixedHour",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"policy": {
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "pl_streaming_curated_to_stg_core_mdl",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"fixedHourUtc": {
												"value": "@pipeline().parameters.fixedHourUtc",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					},
					{
						"name": "Ifrange",
						"type": "IfCondition",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(pipeline().parameters.processMode, 'range')",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "ExecutePipeline_range",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"policy": {
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "pl_streaming_backfill_range",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"startHourUtc": {
												"value": "@pipeline().parameters.startHourUtc",
												"type": "Expression"
											},
											"endHourUtc": {
												"value": "@pipeline().parameters.endHourUtc",
												"type": "Expression"
											}
										}
									}
								}
							]
						}
					}
				],
				"concurrency": 1,
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"processMode": {
						"type": "string",
						"defaultValue": "lastHour"
					},
					"fixedHourUtc": {
						"type": "string"
					},
					"startHourUtc": {
						"type": "string"
					},
					"endHourUtc": {
						"type": "string"
					}
				},
				"variables": {
					"currentHour": {
						"type": "String"
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_streaming_curated_to_stg_core_mdl')]",
				"[concat(variables('factoryId'), '/pipelines/pl_streaming_backfill_range')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/t_daily_nyctaxi')]",
			"type": "Microsoft.DataFactory/factories/triggers",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"runtimeState": "Stopped",
				"pipeline": {
					"pipelineReference": {
						"referenceName": "pl_daily_nyctaxi",
						"type": "PipelineReference"
					},
					"parameters": {
						"dataset": "[parameters('t_daily_nyctaxi_properties_pipeline_parameters_dataset')]",
						"run_date": "[parameters('t_daily_nyctaxi_properties_pipeline_parameters_run_date')]"
					}
				},
				"type": "TumblingWindowTrigger",
				"typeProperties": {
					"frequency": "Hour",
					"interval": 24,
					"startTime": "2025-09-19T17:54:00Z",
					"endTime": "2025-09-20T17:54:00Z",
					"delay": "00:00:00",
					"maxConcurrency": 50,
					"retryPolicy": {
						"intervalInSeconds": 30
					},
					"dependsOn": []
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_daily_nyctaxi')]"
			]
		}
	]
}